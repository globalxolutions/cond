
= Cond

== Description

Intercept exceptions being raised and resolve errors without unwinding
the stack.

== Synopsis

  require 'cond'
  include Cond
  
  def divide(x, y)
    restartable do
      on :return_this_instead do |value|
        return value
      end
      raise ZeroDivisionError if y == 0
      x/y
    end
  end
  
  handling do
    on ZeroDivisionError do |exception|
      invoke_restart :return_this_instead, 42
    end
    puts divide(10, 2)  # => 5
    puts divide(18, 3)  # => 6
    puts divide(4, 0)   # => 42
    puts divide(7, 0)   # => 42
  end

== Other Examples

  examples/handlers.rb
  examples/restarts.rb
  test/test_*.rb

== Install

  % gem install cond

or

  % ruby install.rb [--uninstall]

== Overview

+Cond+ allows errors to be handled at the place where they occur.  You
decide whether or not the stack should be unwound, depending on the
circumstance and the error.

The system is divided into two parts: _restarts_ and _handlers_.
Restarts are like panic buttons which are placed in the vicinity of
error-producing code.  The panic buttons reside on a large control
panel, and handlers are like persons attending to this control panel.

When +raise+ is called and there is a related handler for the error,
the normal raise mechanism of unwinding the stack is suspended while
the handler is called instead.  At this time, the handler may invoke
one of the available restarts.

  (1) program start (stack top) --> +
                                    |
                                    |
                                    |
                                    | .- handler_a 
                                    |/             
  (2) handlers set up here -------> +--- handler_b 
                                    |\             
                                    | .- handler_c -----+
                                    |       .           |
                                    |      /|\          |
                                    |       |           |
                                    |       |           | (5) handler 
                                    |       |           |     calls
                                    |       |           |     restart
                                    |       |           |
           +--------->------------- | ------+           |
           |                        |  (4) exception    |
           |                        |      sent to      |
           |                        |      handler      |
           |                        |                   |
           |                        |                   |
           |                        |                   |
           ^                        | .- restart_x      |
                                    |/                  |
  (3) exception raised here ------> +--- restart_y <----+
                                     \            
                                      .- restart_z

A handler may find a way to negate the problem and, by pushing one of
the restart buttons, allow execution to continue as normal from the
point where +raise+ was called.  Or a handler may choose to allow the
exception to propagate in the usual unwinding fashion, as if the
handler was never called.

It is ideal for library writers to provide restarts inside their
library.  They can anticipate errors and offer options in dealing with
them.  Their understanding of the code is likely to be better than
anyone using it, so they are best equipped to design the panic
buttons.

When you rescue an exception which was raised deep inside a library,
at that moment it is often too late.  You may have lost a significant
portion of your application state from the stack being rewound.

There is another restarts/handlers analogy in addition to the one of
panic-button/control-panel-guy.

The condition system takes place in bullet time.  The exception is the
bullet coming at you.  The distance between you and the bullet
represents the stack.  When you rescue an exception, the bullet has
already entered your body.  You are wounded and need to be rescued.
But wait -- you are inside a +rescue+ block: you are rescuer!

What if you could stop time at the moment the bullet is fired?  This
is what +Cond+'s redefinition of Kernel#raise does.  It allows you to
ponder the present situation while the bullet hangs in mid-air.

In order to keep the analogy going, the person firing at you would not
be a person but a robot.  The robot's creator placed a button on the
robot's chest which says, "Press here if robot is malfunctioning and
firing bullets." That's the restart.  Finally, you are the handler --
you decide whether to get shot (which might be best after all) or to
press the button.

== Technical Notes

+Cond+ has been tested on MRI 1.8.6, 1.8.7, 1.9, and the latest jruby.

Each thread keeps its own list of handlers, restarts, and other data.
All operations are fully thread-safe.

It is not required to <tt>include Cond</tt>.  The includable methods
of +Cond+ are <tt>module_function</tt>s and are thus callable via e.g.
<tt>Cond.handling</tt>.

+Cond+ hides private modules and classes inside Cond::CondInner in
order to improve the hygiene of <tt>include Cond</tt> and encourage
its use.

Except for the (backward-compatible) redefinition of +Kernel#raise+,
+Cond+ does not silently modify any of the standard classes.

=== Implementation

The implementation is small and simple: it basically consists of two
per-thread stacks of hashes (handlers and restarts) and a redefinition
of +raise+.

The syntax shown in the above synopsis is a thin layer concealing the
underlying hashes.  It is equivalent to the following raw form.  You
are free to use either form according to taste or circumstances.

=== Raw Form

  require 'cond'
  
  def divide(x, y)
    restarts = {
      :return_this_instead => lambda { |value|
        throw :leave, value
      }
    }
    catch :leave do
      Cond.with_restarts restarts do
        raise ZeroDivisionError if y == 0
        x/y
      end
    end
  end
  
  handlers = {
    ZeroDivisionError => lambda { |exception|
      Cond.invoke_restart :return_this_instead, 42
    }
  }
  Cond.with_handlers handlers do
    puts divide(10, 2)  # => 5
    puts divide(18, 3)  # => 6
    puts divide(4, 0)   # => 42
    puts divide(7, 0)   # => 42
  end

=== Limitations

Because the implementation redefines +raise+, there must be a call to
+raise+ inside Ruby code (as opposed to C code) for a handler to be
invoked.

The above synopsis gives an example: Why is there a check for division
by zero when +ZeroDivisionError+ would be raised anyway?  Because
<tt>Fixnum#/</tt> is written in C.

It is still possible for handlers to intercept these raises, but it
requires redefining a wrapped version of the method in question:

  Cond.wrap_instance_method(Fixnum, :/)

Once this has been called, the line

  raise ZeroDivisionError if y == 0

is unnecessary.

=== Further

Peter Seibel discusses the Lisp condition system in this video (I have
fast-forwarded to the relevant part),

http://video.google.com/videoplay?docid=448441135356213813#41m30s

and in his book

http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html

A few examples given there have been translated to Ruby in
examples/seibel_pcl.rb.

== Links

* Documentation: http://cond.rubyforge.org
* Rubyforge home: http://rubyforge.org/projects/cond/
* Manual download: http://rubyforge.org/frs/?group_id=7916
* Repository: http://github.com/quix/cond/tree/master

== Author

* James M. Lawrence <quixoticsycophant@gmail.com>

== License

Copyright (c) 2009 James M. Lawrence.  All rights reserved.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
